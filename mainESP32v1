//pio run -t erase
//Código de la ESP32 principal V1
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "esp_netif.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/adc.h"
#include "driver/gpio.h"
#include "esp_adc_cal.h"
#include "esp_timer.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_http_server.h"
#include "esp_bt.h"
#include "esp_bt_main.h"
#include "esp_gap_ble_api.h"
#include "esp_gatts_api.h"

// Pines
#define sensorTurbidez ADC1_CHANNEL_6  // GPIO34
#define sensorLluvia   ADC1_CHANNEL_7  // GPIO35
#define pinFlujo       GPIO_NUM_26
#define pinRelay       GPIO_NUM_27
#define voltajeRef     1100
#define numMuestras    800

// Variables globales
static const char *TAG = "SCALL-ESP32";

volatile uint32_t contadorPulsos = 0;
uint64_t totalPulsos = 0;
float valorNTU = 0, voltaje = 0, humedad = 0, flujo = 0, litros = 0;

bool wifiConfigurado = false;
bool wifiConectado = false;

// BLE
#define GATTS_SERVICE_UUID 0x00FF
#define GATTS_CHAR_UUID    0xFF01
#define GATTS_NUM_HANDLE   4

static uint16_t conexion_id = 0;
static uint16_t gatts_if_almacenado = 0;

char ssid_recibido[32] = {0};
char password_recibido[64] = {0};
bool credenciales_recibidas = false;

// Utilidades
float redondear(float v, int d) {
    float f = powf(10.0f, d);
    return roundf(v * f) / f;
}

float calcularNTU(float v) {
    float ntu = -1204.82f * v + 2204.8f;
    if (ntu < 0) ntu = 0;
    if (ntu > 3000) ntu = 3000;
    return ntu;
}

static void IRAM_ATTR interrupcionFlujo(void *arg) { 
    contadorPulsos++; 
}

// NVS
void guardarCredencialesWiFi(const char *ssid, const char *password) {
    nvs_handle_t h;
    if (nvs_open("storage", NVS_READWRITE, &h) == ESP_OK) {
        nvs_set_str(h, "wifi_ssid", ssid);
        nvs_set_str(h, "wifi_pass", password);
        nvs_commit(h);
        nvs_close(h);
        ESP_LOGI(TAG, "Credenciales WiFi guardadas");
    }
}

bool cargarCredencialesWiFi(char *ssid, char *password) {
    nvs_handle_t h;
    if (nvs_open("storage", NVS_READONLY, &h) != ESP_OK) return false;

    size_t s_len = 32, p_len = 64;
    esp_err_t e1 = nvs_get_str(h, "wifi_ssid", ssid, &s_len);
    esp_err_t e2 = nvs_get_str(h, "wifi_pass", password, &p_len);
    nvs_close(h);
    return (e1 == ESP_OK && e2 == ESP_OK);
}

// HTTP
static esp_err_t manejadorDatos(httpd_req_t *req) {
    char res[200];
    snprintf(res, sizeof(res),
             "{\"ntu\":%.2f,\"voltaje\":%.2f,\"humedad\":%.2f,"
             "\"flujo\":%.2f,\"litros\":%.2f}",
             valorNTU, voltaje, humedad, flujo, litros);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
    httpd_resp_send(req, res, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

static esp_err_t manejadorRelay(httpd_req_t *req) {
    char buf[10];
    int len = httpd_req_recv(req, buf, sizeof(buf));
    if (len > 0) {
        if (strncmp(buf, "on", 2) == 0) {
            gpio_set_level(pinRelay, 1);
            ESP_LOGI(TAG, "✓ Relay encendido");
        }
        else if (strncmp(buf, "off", 3) == 0) {
            gpio_set_level(pinRelay, 0);
            ESP_LOGI(TAG, "✓ Relay apagado");
        }
    }
    httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

httpd_handle_t iniciarServidorWeb(void) {
    httpd_config_t cfg = HTTPD_DEFAULT_CONFIG();
    httpd_handle_t srv = NULL;
    if (httpd_start(&srv, &cfg) == ESP_OK) {
        httpd_uri_t u1 = { .uri="/datos", .method=HTTP_GET, .handler=manejadorDatos };
        httpd_uri_t u2 = { .uri="/relay", .method=HTTP_POST, .handler=manejadorRelay };
        httpd_register_uri_handler(srv, &u1);
        httpd_register_uri_handler(srv, &u2);
        ESP_LOGI(TAG, "✓ Servidor HTTP iniciado");
    }
    return srv;
}

// WiFi
static void eventoWiFi(void *arg, esp_event_base_t base, int32_t id, void *data) {
    if (base == WIFI_EVENT && id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (base == WIFI_EVENT && id == WIFI_EVENT_STA_DISCONNECTED) {
        wifiConectado = false;
        ESP_LOGW(TAG, "WiFi desconectado, reintentando...");
        vTaskDelay(pdMS_TO_TICKS(5000));
        esp_wifi_connect();
    } else if (base == IP_EVENT && id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t *ev = (ip_event_got_ip_t *)data;
        ESP_LOGI(TAG, "✓ WiFi conectado! IP: " IPSTR, IP2STR(&ev->ip_info.ip));
        wifiConectado = true;
        iniciarServidorWeb();
    }
}

void configurarWiFi(const char *ssid, const char *password) {
    if (!wifiConfigurado) {
        esp_netif_init();
        esp_event_loop_create_default();
        esp_netif_create_default_wifi_sta();
        wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
        esp_wifi_init(&cfg);
        esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &eventoWiFi, NULL);
        esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &eventoWiFi, NULL);
        wifiConfigurado = true;
    }

    wifi_config_t conf = {0};
    strncpy((char *)conf.sta.ssid, ssid, sizeof(conf.sta.ssid) - 1);
    strncpy((char *)conf.sta.password, password, sizeof(conf.sta.password) - 1);

    ESP_LOGI(TAG, "Conectando a WiFi: %s", ssid);
    esp_wifi_set_mode(WIFI_MODE_STA);
    esp_wifi_set_config(ESP_IF_WIFI_STA, &conf);
    esp_wifi_start();
}

// BLE
static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) {
    switch (event) {
        case ESP_GATTS_REG_EVT: {
            ESP_LOGI(TAG, "BLE GATT Server registrado");
            gatts_if_almacenado = gatts_if;

            esp_ble_gap_set_device_name("SCALL-ESP32");

            esp_ble_adv_data_t adv_data = {
                .set_scan_rsp = false,
                .include_name = true,
                .include_txpower = true,
                .min_interval = 0x20,
                .max_interval = 0x40,
                .appearance = 0x00,
                .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT)
            };

            static esp_ble_adv_params_t adv_params = {
                .adv_int_min = 0x20,
                .adv_int_max = 0x40,
                .adv_type = ADV_TYPE_IND,
                .own_addr_type = BLE_ADDR_TYPE_PUBLIC,
                .channel_map = ADV_CHNL_ALL,
                .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY
            };

            esp_ble_gap_config_adv_data(&adv_data);
            esp_ble_gap_start_advertising(&adv_params);

            esp_gatt_srvc_id_t sid = {
                .is_primary = true,
                .id.inst_id = 0,
                .id.uuid.len = ESP_UUID_LEN_16,
                .id.uuid.uuid.uuid16 = GATTS_SERVICE_UUID
            };
            esp_ble_gatts_create_service(gatts_if, &sid, GATTS_NUM_HANDLE);
            break;
        }

        case ESP_GATTS_CREATE_EVT: {
            ESP_LOGI(TAG, "Servicio BLE creado");
            esp_ble_gatts_start_service(param->create.service_handle);

            esp_bt_uuid_t uuid = { .len = ESP_UUID_LEN_16, .uuid.uuid16 = GATTS_CHAR_UUID };
            esp_gatt_char_prop_t prop = ESP_GATT_CHAR_PROP_BIT_READ |
                                        ESP_GATT_CHAR_PROP_BIT_WRITE |
                                        ESP_GATT_CHAR_PROP_BIT_NOTIFY;

            esp_ble_gatts_add_char(param->create.service_handle, &uuid,
                                   ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
                                   prop, NULL, NULL);
            break;
        }

        case ESP_GATTS_CONNECT_EVT:
            ESP_LOGI(TAG, "Cliente BLE conectado");
            conexion_id = param->connect.conn_id;
            break;

        case ESP_GATTS_DISCONNECT_EVT: {
            ESP_LOGI(TAG, "Cliente BLE desconectado");
            conexion_id = 0;
            
            static esp_ble_adv_params_t adv_params = {
                .adv_int_min = 0x20,
                .adv_int_max = 0x40,
                .adv_type = ADV_TYPE_IND,
                .own_addr_type = BLE_ADDR_TYPE_PUBLIC,
                .channel_map = ADV_CHNL_ALL,
                .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY
            };
            esp_ble_gap_start_advertising(&adv_params);
            break;
        }

        case ESP_GATTS_WRITE_EVT: {
            if (!param || !param->write.value || param->write.len <= 0) {
                ESP_LOGW(TAG, "WRITE vacío o inválido");
                break;
            }

            ESP_LOGI(TAG, "=== Datos recibidos por BLE ===");
            ESP_LOGI(TAG, "Longitud: %d bytes", param->write.len);
            
            if (param->write.need_rsp) {
                esp_gatt_rsp_t rsp = {0};
                rsp.attr_value.handle = param->write.handle;
                esp_ble_gatts_send_response(gatts_if, param->write.conn_id,
                                            param->write.trans_id, ESP_GATT_OK, &rsp);
                ESP_LOGI(TAG, "Respuesta BLE enviada");
            }

            char datos[128] = {0};
            int len_copiar = (param->write.len < sizeof(datos) - 1) ? param->write.len : sizeof(datos) - 1;
            memcpy(datos, param->write.value, len_copiar);
            datos[len_copiar] = '\0';
            
            ESP_LOGI(TAG, "Datos completos: '%s'", datos);
            
            char *separador = strchr(datos, ':');
            if (separador != NULL) {
                *separador = '\0';
                strncpy(ssid_recibido, datos, sizeof(ssid_recibido) - 1);
                strncpy(password_recibido, separador + 1, sizeof(password_recibido) - 1);
                
                ESP_LOGI(TAG, "✓ Credenciales WiFi recibidas:");
                ESP_LOGI(TAG, "  SSID: '%s'", ssid_recibido);
                ESP_LOGI(TAG, "  PASS: '%s'", password_recibido);
                
                credenciales_recibidas = true;
            } else {
                ESP_LOGE(TAG, "✗ Formato inválido. Esperaba SSID:PASSWORD");
            }
            
            ESP_LOGI(TAG, "===============================");
            break;
        }

        default:
            break;
    }
}

void iniciarBLE(void) {
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));
    esp_bt_controller_config_t cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    esp_bt_controller_init(&cfg);
    esp_bt_controller_enable(ESP_BT_MODE_BLE);
    esp_bluedroid_init();
    esp_bluedroid_enable();
    esp_ble_gatts_register_callback(gatts_event_handler);
    esp_ble_gap_register_callback(NULL);
    esp_ble_gatts_app_register(0);
    ESP_LOGI(TAG, "✓ Servidor BLE iniciado: SCALL-ESP32");
}

// Tarea credenciales
void procesar_credenciales_task(void *pv) {
    while (1) {
        if (credenciales_recibidas) {
            credenciales_recibidas = false;
            ESP_LOGI(TAG, "Procesando credenciales WiFi...");
            vTaskDelay(pdMS_TO_TICKS(500));
            guardarCredencialesWiFi(ssid_recibido, password_recibido);
            configurarWiFi(ssid_recibido, password_recibido);
        }
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

// Main
void app_main(void) {
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    ESP_LOGI(TAG, "=============================");
    ESP_LOGI(TAG, "   SCALL ESP32 - Iniciando");
    ESP_LOGI(TAG, "=============================");

    iniciarBLE();

    char ssid[32] = {0}, pass[64] = {0};
    if (cargarCredencialesWiFi(ssid, pass)) {
        ESP_LOGI(TAG, "Credenciales guardadas encontradas");
        configurarWiFi(ssid, pass);
    } else {
        ESP_LOGI(TAG, "Esperando configuración BLE...");
    }

    adc1_config_width(ADC_WIDTH_BIT_12);
    adc1_config_channel_atten(sensorTurbidez, ADC_ATTEN_DB_12);
    adc1_config_channel_atten(sensorLluvia, ADC_ATTEN_DB_12);

    esp_adc_cal_characteristics_t ch;
    esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_DB_12, ADC_WIDTH_BIT_12, voltajeRef, &ch);

    gpio_config_t cfg = {
        .intr_type = GPIO_INTR_POSEDGE,
        .mode = GPIO_MODE_INPUT,
        .pin_bit_mask = (1ULL << pinFlujo),
        .pull_down_en = 0,
        .pull_up_en = 1
    };
    gpio_config(&cfg);
    gpio_install_isr_service(0);
    gpio_isr_handler_add(pinFlujo, interrupcionFlujo, NULL);

    gpio_reset_pin(pinRelay);
    gpio_set_direction(pinRelay, GPIO_MODE_OUTPUT);
    gpio_set_level(pinRelay, 0);

    ESP_LOGI(TAG, "✓ Sensores configurados");
    ESP_LOGI(TAG, "=============================");

    xTaskCreate(procesar_credenciales_task, "wifi_task", 4096, NULL, 5, NULL);

    // LOOP PRINCIPAL - Solo lee sensores si WiFi está conectado
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(2000));

        // Si NO hay WiFi, mostrar mensaje y NO leer sensores
        if (!wifiConectado) {
            ESP_LOGI(TAG, "Esperando conexión WiFi...");
            continue;  // Saltar al siguiente ciclo sin leer sensores
        }

        // A partir de aquí, SOLO se ejecuta si WiFi está conectado
        contadorPulsos = 0;
        vTaskDelay(pdMS_TO_TICKS(2000));

        totalPulsos += contadorPulsos;
        flujo = contadorPulsos / 7.5f;
        litros = totalPulsos / 450.0f;

        uint32_t sumaT = 0;
        for (int i = 0; i < numMuestras; i++) sumaT += adc1_get_raw(sensorTurbidez);
        uint32_t promT = sumaT / numMuestras;
        uint32_t voltT = esp_adc_cal_raw_to_voltage(promT, &ch);
        voltaje = redondear(voltT / 1000.0f, 2);
        valorNTU = calcularNTU(voltaje);

        uint32_t sumaL = 0;
        for (int i = 0; i < numMuestras; i++) sumaL += adc1_get_raw(sensorLluvia);
        uint32_t promL = sumaL / numMuestras;
        humedad = redondear((promL * 100.0f) / 4095.0f, 1);

        ESP_LOGI(TAG, "NTU:%.2f V:%.2f H:%.1f%% F:%.2f L/min L:%.2f L",
                 valorNTU, voltaje, humedad, flujo, litros);
    }
}
